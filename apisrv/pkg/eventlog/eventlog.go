package eventlog

import (
	"bytes"
	"crypto"
	"crypto/sha1"
	"crypto/sha256"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"sort"
	"strings"

	"github.com/google/go-tpm/tpm2"
)

func (e ReplayError) affected(PCR int) bool {
	for _, p := range e.InvalidPCRs {
		if p == PCR {
			return true
		}
	}
	return false
}

// Error returns a human-friendly description of replay failures.
func (e ReplayError) Error() string {
	return fmt.Sprintf("event log failed to verify: the following registers failed to replay: %v", e.InvalidPCRs)
}

var eventTypeNames = map[EventType]string{
	PrebootCert:          "Preboot Cert",
	PostCode:             "POST Code",
	unused:               "Unused",
	NoAction:             "No Action",
	Separator:            "Separator",
	Action:               "Action",
	EventTag:             "Event Tag",
	SCRTMContents:        "S-CRTM Contents",
	SCRTMVersion:         "S-CRTM Version",
	CpuMicrocode:         "CPU Microcode",
	PlatformConfigFlags:  "Platform Config Flags",
	TableOfDevices:       "Table of Devices",
	CompactHash:          "Compact Hash",
	Ipl:                  "IPL",
	IplPartitionData:     "IPL Partition Data",
	NonhostCode:          "Non-Host Code",
	NonhostConfig:        "Non-HostConfig",
	NonhostInfo:          "Non-Host Info",
	OmitBootDeviceEvents: "Omit Boot Device Events",

	EFIEventBase:               "EFI Event Base",
	EFIVariableDriverConfig:    "EFI Variable Driver Config",
	EFIVariableBoot:            "EFI Variable Boot",
	EFIBootServicesApplication: "EFI Boot Services Application",
	EFIBootServicesDriver:      "EFI Boot Services Driver",
	EFIRuntimeServicesDriver:   "EFI Runtime Services Driver",
	EFIGPTEvent:                "EFI GPT Event",
	EFIAction:                  "EFI Action",
	EFIPlatformFirmwareBlob:    "EFI Platform Firmware Blob",
	EFIVariableAuthority:       "EFI Variable Authority",
	EFIHandoffTables:           "EFI Handoff Tables",
	EFIHCRTMEvent:              "EFI H-CRTM Event",
}

// String returns the Spec name of the EventType, for example "EV_ACTION". If
// unknown, it returns a formatted string of the EventType value.
func (e EventType) String() string {
	if s, ok := eventTypeNames[EventType(e)]; ok {
		return s
	}
	// NOTE: 0x00000013-0x0000FFFF are reserverd. Should we include that
	// information in the formatting?
	return fmt.Sprintf("EventType(0x%08x)", EventType(e))
}

// DigestEquals compares event Digest with external digest
func (e *Event) DigestEquals(b []byte) error {
	if len(e.Digest) == 0 {
		return errors.New("no digests present")
	}

	switch len(e.Digest) {
	case crypto.SHA256.Size():
		s := sha256.Sum256(b)
		if bytes.Equal(s[:], e.Digest) {
			return nil
		}
	case crypto.SHA1.Size():
		s := sha1.Sum(b)
		if bytes.Equal(s[:], e.Digest) {
			return nil
		}
	default:
		return fmt.Errorf("cannot compare hash of length %d", len(e.Digest))
	}

	return fmt.Errorf("digest (len %d) does not match", len(e.Digest))
}

func (e *EventLog) clone() *EventLog {
	out := EventLog{
		Algs:      make([]HashAlg, len(e.Algs)),
		rawEvents: make([]rawEvent, len(e.rawEvents)),
	}
	copy(out.Algs, e.Algs)
	copy(out.rawEvents, e.rawEvents)
	return &out
}

// Events returns events that have not been replayed against the PCR values and
// are therefore unverified. The returned events contain the digest that matches
// the provided hash algorithm, or are empty if that event didn't contain a
// digest for that hash.
//
// This method is insecure and should only be used for debugging.
func (e *EventLog) Events(hash HashAlg) []Event {
	var events []Event
	for _, re := range e.rawEvents {
		ev := Event{
			Index: re.index,
			Type:  re.typ,
			Data:  re.data,
			Alg:   hash,
		}

		for _, digest := range re.digests {
			if hash.CryptoHash() != digest.hash {
				continue
			}
			ev.Digest = digest.data
			break
		}
		events = append(events, ev)
	}
	return events
}

// Verify replays the event log against a TPM's PCR values, returning the
// events which could be matched to a provided PCR value.
//
// PCRs provide no security guarentees unless they're attested to have been
// generated by a TPM. Verify does not perform these checks.
//
// An error is returned if the replayed digest for events with a given PCR
// index do not match any provided value for that PCR index.
func (e *EventLog) Verify(pcrs []PCR) ([]Event, error) {
	events, err := e.verify(pcrs)
	// If there were any issues replaying the PCRs, try each of the workarounds
	// in turn.
	// TODO Allow workarounds to be combined.
	if rErr, isReplayErr := err.(ReplayError); isReplayErr {
		for _, wkrd := range eventlogWorkarounds {
			if !rErr.affected(wkrd.affectedPCR) {
				continue
			}
			el := e.clone()
			if err := wkrd.apply(el); err != nil {
				return nil, fmt.Errorf("failed applying workaround %q: %v", wkrd.id, err)
			}
			if events, err := el.verify(pcrs); err == nil {
				return events, nil
			}
		}
	}

	return events, err
}

func (e *EventLog) Replay(pcrs []PCR) ([][]byte, error) {
	replays, _, err := replayEvents(e.rawEvents, pcrs)
	return replays, err
}

func (e *EventLog) verify(pcrs []PCR) ([]Event, error) {
	_, events, err := replayEvents(e.rawEvents, pcrs)
	if err != nil {
		if _, isReplayErr := err.(ReplayError); isReplayErr {
			return events, err
		}
		return events, fmt.Errorf("pcrs failed to replay: %v", err)
	}
	return events, nil
}

func extend(pcr PCR, replay []byte, e rawEvent, locality byte) (pcrDigest []byte, eventDigest []byte, err error) {
	h := pcr.DigestAlg

	for _, digest := range e.digests {
		if digest.hash != pcr.DigestAlg {
			continue
		}
		if len(digest.data) != len(pcr.Digest) {
			return nil, nil, fmt.Errorf("digest data length (%d) doesn't match PCR digest length (%d)", len(digest.data), len(pcr.Digest))
		}
		hash := h.New()
		if len(replay) != 0 {
			hash.Write(replay)
		} else {
			b := make([]byte, h.Size())
			b[h.Size()-1] = locality
			hash.Write(b)
		}
		hash.Write(digest.data)
		return hash.Sum(nil), digest.data, nil
	}
	return nil, nil, fmt.Errorf("no event digest matches pcr algorithm: %v", pcr.DigestAlg)
}

// replayPCR replays the event log for a specific PCR, using pcr and
// event digests with the algorithm in pcr. An error is returned if the
// replayed values do not match the final PCR digest, or any event tagged
// with that PCR does not posess an event digest with the specified algorithm.
func replayPCR(rawEvents []rawEvent, pcr PCR) ([]byte, []Event, bool) {
	var (
		replay    []byte
		outEvents []Event
		locality  byte
		alg       HashAlg
	)

	switch pcr.DigestAlg {
	case crypto.SHA1:
		alg = HashSHA1
	case crypto.SHA256:
		alg = HashSHA256
	}

	for _, e := range rawEvents {
		if e.index != pcr.Index {
			continue
		}
		// If TXT is enabled then the first event for PCR0
		// should be a StartupLocality event. The final byte
		// of this event indicates the locality from which
		// TPM2_Startup() was issued. The initial value of
		// PCR0 is equal to the locality.
		if e.typ == eventTypeNoAction {
			if pcr.Index == 0 && len(e.data) == 17 && strings.HasPrefix(string(e.data), "StartupLocality") {
				locality = e.data[len(e.data)-1]
			}
			continue
		}
		replayValue, digest, err := extend(pcr, replay, e, locality)
		if err != nil {
			return nil, nil, false
		}
		replay = replayValue
		outEv := Event{
			Sequence: e.sequence,
			Data:     e.data,
			Digest:   digest,
			Index:    pcr.Index,
			Type:     e.typ,
			Alg:      alg,
		}
		outEvents = append(outEvents, outEv)
	}

	if len(outEvents) > 0 && !bytes.Equal(replay, pcr.Digest) {
		return replay, outEvents, false
	}
	return replay, outEvents, true
}

func replayEvents(rawEvents []rawEvent, pcrs []PCR) ([][]byte, []Event, error) {
	var (
		replays        = make([][]byte, len(pcrs))
		invalidReplays []int
		verifiedEvents []Event
		allPCRReplays  = map[int][]pcrReplayResult{}
	)

	// Replay the event log for every PCR and digest algorithm combination.
	for idx, pcr := range pcrs {
		replay, events, ok := replayPCR(rawEvents, pcr)
		allPCRReplays[pcr.Index] = append(allPCRReplays[pcr.Index], pcrReplayResult{events, ok})
		replays[idx] = replay
	}

	// Record PCR indices which do not have any successful replay. Record the
	// events for a successful replay.
	for i, replaysForPCR := range allPCRReplays {
		successful := false
		for _, replay := range replaysForPCR {
			if replay.successful {
				// We consider the PCR verified at this stage: The replay of values with
				// one digest algorithm matched a provided value.
				// We still save all events of every bank that could be replayed successfully
				verifiedEvents = append(verifiedEvents, replay.events...)
				successful = true
			}
		}
		if !successful {
			invalidReplays = append(invalidReplays, i)
		}
	}

	if len(invalidReplays) > 0 {
		events := make([]Event, 0, len(rawEvents))
		for _, e := range rawEvents {
			events = append(events, Event{e.sequence, e.index, e.typ, e.data, nil, 0})
		}
		return replays, nil, ReplayError{
			Events:      events,
			InvalidPCRs: invalidReplays,
		}
	}

	sort.Slice(verifiedEvents, func(i int, j int) bool {
		return verifiedEvents[i].Sequence < verifiedEvents[j].Sequence
	})
	return replays, verifiedEvents, nil
}

// ParseEventLog parses an unverified measurement log.
func ParseEventLog(measurementLog []byte) (*EventLog, error) {
	var specID *specIDEvent
	r := bytes.NewBuffer(measurementLog)
	parseFn := parseRawEvent
	var el EventLog
	e, err := parseFn(r, specID)
	if err != nil {
		return nil, fmt.Errorf("parse first event: %v", err)
	}
	if e.typ == eventTypeNoAction && len(e.data) >= binary.Size(specIDEventHeader{}) {
		specID, err = parseSpecIDEvent(e.data)
		if err != nil {
			return nil, fmt.Errorf("failed to parse spec ID event: %v", err)
		}
		for _, alg := range specID.algs {
			switch tpm2.Algorithm(alg.ID) {
			case tpm2.AlgSHA1:
				el.Algs = append(el.Algs, HashSHA1)
			case tpm2.AlgSHA256:
				el.Algs = append(el.Algs, HashSHA256)
			}
		}
		if len(el.Algs) == 0 {
			return nil, fmt.Errorf("measurement log didn't use sha1 or sha256 digests")
		}
		// Switch to parsing crypto agile events. Don't include this in the
		// replayed events since it intentionally doesn't extend the PCRs.
		//
		// Note that this doesn't actually guarentee that events have SHA256
		// digests.
		parseFn = parseRawEvent2
	} else {
		el.Algs = []HashAlg{HashSHA1}
		el.rawEvents = append(el.rawEvents, e)
	}
	sequence := 1
	for r.Len() != 0 {
		e, err := parseFn(r, specID)
		if err != nil {
			return nil, err
		}
		e.sequence = sequence
		sequence++
		el.rawEvents = append(el.rawEvents, e)
	}
	return &el, nil
}

// Expected values for various Spec ID Event fields.
// https://trustedcomputinggroup.org/wp-content/uploads/EFI-Protocol-Specification-rev13-160330final.pdf#page=19
var wantSignature = [16]byte{0x53, 0x70,
	0x65, 0x63, 0x20, 0x49,
	0x44, 0x20, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x30,
	0x33, 0x00} // "Spec ID Event03\0"

// parseSpecIDEvent parses a TCG_EfiSpecIDEventStruct structure from the reader.
//
// https://trustedcomputinggroup.org/wp-content/uploads/EFI-Protocol-Specification-rev13-160330final.pdf#page=18
func parseSpecIDEvent(b []byte) (*specIDEvent, error) {
	r := bytes.NewReader(b)
	var header specIDEventHeader
	if err := binary.Read(r, binary.LittleEndian, &header); err != nil {
		return nil, fmt.Errorf("reading event header: %w: %X", err, b)
	}
	if header.Signature != wantSignature {
		return nil, fmt.Errorf("invalid spec id signature: %x", header.Signature)
	}
	if header.VersionMajor != wantMajor {
		return nil, fmt.Errorf("invalid spec major version, got %02x, wanted %02x",
			header.VersionMajor, wantMajor)
	}
	if header.VersionMinor != wantMinor {
		return nil, fmt.Errorf("invalid spec minor version, got %02x, wanted %02x",
			header.VersionMajor, wantMinor)
	}

	specAlg := specAlgSize{}
	e := specIDEvent{}
	for i := 0; i < int(header.NumAlgs); i++ {
		if err := binary.Read(r, binary.LittleEndian, &specAlg); err != nil {
			return nil, fmt.Errorf("reading algorithm: %v", err)
		}
		e.algs = append(e.algs, specAlg)
	}

	var vendorInfoSize uint8
	if err := binary.Read(r, binary.LittleEndian, &vendorInfoSize); err != nil {
		return nil, fmt.Errorf("reading vender info size: %v", err)
	}
	if r.Len() != int(vendorInfoSize) {
		return nil, fmt.Errorf("reading vendor info, expected %d remaining bytes, got %d", vendorInfoSize, r.Len())
	}
	return &e, nil
}

func (e *eventSizeErr) Error() string {
	return fmt.Sprintf("event data size (%d bytes) is greater than remaining measurement log (%d bytes)", e.eventSize, e.logSize)
}

func parseRawEvent(r *bytes.Buffer, specID *specIDEvent) (event rawEvent, err error) {
	var h rawEventHeader
	if err = binary.Read(r, binary.LittleEndian, &h); err != nil {
		return event, fmt.Errorf("header deserialization error: %w", err)
	}
	if h.EventSize > uint32(r.Len()) {
		return event, &eventSizeErr{h.EventSize, r.Len()}
	}

	data := make([]byte, int(h.EventSize))
	if _, err := io.ReadFull(r, data); err != nil {
		return event, fmt.Errorf("reading data error: %w", err)
	}

	digests := []digest{{hash: crypto.SHA1, data: h.Digest[:]}}

	return rawEvent{
		typ:     EventType(h.Type),
		data:    data,
		index:   int(h.PCRIndex),
		digests: digests,
	}, nil
}

func parseRawEvent2(r *bytes.Buffer, specID *specIDEvent) (event rawEvent, err error) {
	var h rawEvent2Header

	if err = binary.Read(r, binary.LittleEndian, &h); err != nil {
		return event, err
	}
	event.typ = EventType(h.Type)
	event.index = int(h.PCRIndex)

	// parse the event digests
	var numDigests uint32
	if err := binary.Read(r, binary.LittleEndian, &numDigests); err != nil {
		return event, err
	}

	for i := 0; i < int(numDigests); i++ {
		var algID uint16
		if err := binary.Read(r, binary.LittleEndian, &algID); err != nil {
			return event, err
		}
		var digest digest

		for _, alg := range specID.algs {
			if alg.ID != algID {
				continue
			}
			if r.Len() < int(alg.Size) {
				return event, fmt.Errorf("reading digest: %v", io.ErrUnexpectedEOF)
			}
			digest.data = make([]byte, alg.Size)
			digest.hash = HashAlg(alg.ID).CryptoHash()
		}
		if len(digest.data) == 0 {
			return event, fmt.Errorf("unknown algorithm ID %x", algID)
		}
		if _, err := io.ReadFull(r, digest.data); err != nil {
			return event, err
		}
		event.digests = append(event.digests, digest)
	}

	// parse event data
	var eventSize uint32
	if err = binary.Read(r, binary.LittleEndian, &eventSize); err != nil {
		return event, err
	}
	if eventSize == 0 {
		return event, errors.New("event data size is 0")
	}
	if eventSize > uint32(r.Len()) {
		return event, &eventSizeErr{eventSize, r.Len()}
	}
	event.data = make([]byte, int(eventSize))
	if _, err := io.ReadFull(r, event.data); err != nil {
		return event, err
	}
	return event, err
}

/*
func ReadEventLog() (*EventLog, error) {
	data, err := MeasurementLog(DefaultTPMDevice)
	if err != nil {
		return nil, err
	}
	log, err := ParseEventLog(data)
	if err != nil {
		return nil, err
	}
	return log, nil
}*/

func verifyEventLog(conn io.ReadWriteCloser, log *EventLog) ([]Event, bool, error) {
	var outEvents []Event
	for _, algo := range log.Algs {
		for i := 0; i < PCRMax; i++ {
			pcr := [1]int{i}
			sel := tpm2.PCRSelection{
				Hash: algo.GoTPMAlg(),
				PCRs: pcr[:],
			}
			pcrs, err := ReadPCRs(conn, sel)
			if err != nil {
				return nil, false, err
			}
			events, err := log.Verify(pcrs)
			if err != nil {
				return nil, false, err
			}
			outEvents = append(outEvents, events...)
		}
	}
	return outEvents, true, nil
}

/*
func ReadHumanEvents(conn io.ReadWriteCloser) (*HumanEventLog, error) {
	var humanLog HumanEventLog
	log, err := ReadEventLog()
	if err != nil {
		return nil, err
	}
	_, humanLog.Verified, err = verifyEventLog(conn, log)
	if err != nil {
		return nil, err
	}
	for _, algo := range log.Algs {
		humanLog.Algorithms = append(humanLog.Algorithms, algo.String())
		tpmEvents, err := ParseEvents(log.Events(algo))
		if err != nil {
			return nil, err
		}
		var parsedEvents []string
		for _, ev := range tpmEvents {
			var eventStr string
			switch ev.(type) {
			case PrebootCertEvent, NoActionEvent, SeparatorEvent,
				EventTagEvent, PlatformConfigFlagsEvent,
				TableOfDevicesEvent, CompactHashEvent,
				IPLPartitionEvent, NonHostCodeEvent,
				NonHostConfigEvent, NonHostInfoEvent,
				UEFIBootServicesApplicationEvent,
				UEFIBootServicesDriverEvent,
				UEFIRuntimeServicesDriverEvent,
				UEFIGPTEvent, UEFIPlatformFirmwareBlobEvent,
				UEFIHandoffTableEvent:
				eventStr = fmt.Sprintf("PCR-%d: %02x | %s |", ev.RawEvent().Index, ev.RawEvent().Digest, ev.RawEvent().Type.String())
			case PostEvent:
				typeEv := ev.(PostEvent)
				eventStr = fmt.Sprintf("PCR-%d: %02x | %s | %s", typeEv.RawEvent().Index, typeEv.RawEvent().Digest, ev.RawEvent().Type.String(), typeEv.Message)
			case ActionEvent:
				typeEv := ev.(ActionEvent)
				eventStr = fmt.Sprintf("PCR-%d: %02x | %s | %s", typeEv.RawEvent().Index, typeEv.RawEvent().Digest, ev.RawEvent().Type.String(), typeEv.Message)
			case CRTMContentEvent:
				typeEv := ev.(CRTMContentEvent)
				eventStr = fmt.Sprintf("PCR-%d: %02x | %s | %s", typeEv.RawEvent().Index, typeEv.RawEvent().Digest, ev.RawEvent().Type.String(), typeEv.Message)
			case CRTMEvent:
				typeEv := ev.(CRTMEvent)
				eventStr = fmt.Sprintf("PCR-%d: %02x | %s | %s", typeEv.RawEvent().Index, typeEv.RawEvent().Digest, ev.RawEvent().Type.String(), typeEv.Message)
			case MicrocodeEvent:
				typeEv := ev.(MicrocodeEvent)
				eventStr = fmt.Sprintf("PCR-%d: %02x | %s | %s", typeEv.RawEvent().Index, typeEv.RawEvent().Digest, ev.RawEvent().Type.String(), typeEv.Message)
			case IPLEvent:
				typeEv := ev.(IPLEvent)
				eventStr = fmt.Sprintf("PCR-%d: %02x | %s | %s", typeEv.RawEvent().Index, typeEv.RawEvent().Digest, ev.RawEvent().Type.String(), typeEv.Message)
			case OmitBootDeviceEventsEvent:
				typeEv := ev.(OmitBootDeviceEventsEvent)
				eventStr = fmt.Sprintf("PCR-%d: %02x | %s | %s", typeEv.RawEvent().Index, typeEv.RawEvent().Digest, ev.RawEvent().Type.String(), typeEv.Message)
			case UEFIBootVariableEvent:
				typeEv := ev.(UEFIBootVariableEvent)
				eventStr = fmt.Sprintf("PCR-%d: %02x | %s | %s", typeEv.RawEvent().Index, typeEv.RawEvent().Digest, ev.RawEvent().Type.String(), typeEv.Description)
			case UEFIActionEvent:
				typeEv := ev.(UEFIActionEvent)
				eventStr = fmt.Sprintf("PCR-%d: %02x | %s | %s", typeEv.RawEvent().Index, typeEv.RawEvent().Digest, ev.RawEvent().Type.String(), typeEv.Message)
			case UEFIVariableAuthorityEvent:
				typeEv := ev.(UEFIVariableAuthorityEvent)
				eventStr = fmt.Sprintf("PCR-%d: %02x | %s | %s", typeEv.RawEvent().Index, typeEv.RawEvent().Digest, ev.RawEvent().Type.String(), typeEv.VariableName)
			case UEFIVariableDriverConfigEvent:
				typeEv := ev.(UEFIVariableDriverConfigEvent)
				eventStr = fmt.Sprintf("PCR-%d: %02x | %s | %s", typeEv.RawEvent().Index, typeEv.RawEvent().Digest, ev.RawEvent().Type.String(), typeEv.VariableName)
			}
			parsedEvents = append(parsedEvents, eventStr)
		}
		switch algo {
		case HashSHA1:
			humanLog.SHA1Events = append(humanLog.SHA1Events, parsedEvents...)
		case HashSHA256:
			humanLog.SHA256Events = append(humanLog.SHA256Events, parsedEvents...)
		default:
			return nil, fmt.Errorf("hash algorithm not supported %d", algo)
		}
	}
	return &humanLog, nil
}
*/
