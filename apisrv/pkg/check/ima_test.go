package check

import (
	"context"
	"crypto/sha1"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"testing"

	"github.com/klauspost/compress/zstd"
	"github.com/stretchr/testify/assert"

	"github.com/immune-gmbh/guard/apisrv/v2/pkg/api"
	"github.com/immune-gmbh/guard/apisrv/v2/pkg/check/baseline"
	"github.com/immune-gmbh/guard/apisrv/v2/pkg/check/policy"
	"github.com/immune-gmbh/guard/apisrv/v2/pkg/eventlog"
	"github.com/immune-gmbh/guard/apisrv/v2/pkg/evidence"
	"github.com/immune-gmbh/guard/apisrv/v2/pkg/issuesv1"
)

func TestBootAggregate(t *testing.T) {
	zero := []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	bootAgg := []byte("\xe0\x21\x5d\xa0\xd2\x9a\xe4\x59\x22\xc4\x8c\x0e\x66\x15\x0a\x29\x4e\xef\xfb\x95")
	pcr10 := []byte("\x66\x61\xD2\xA9\x2F\x33\x24\xD6\x92\x6E\xA1\x29\x7E\x2D\x2C\x19\x47\xF3\xAF\x01")

	h := sha1.New()
	h.Write(zero)
	h.Write(bootAgg)
	sum := h.Sum(nil)

	fmt.Printf("got:  %x\n", sum)
	fmt.Printf("want: %x\n", pcr10)
}

func TestIMALog(t *testing.T) {
	ctx := context.Background()
	buf, err := ioutil.ReadFile("../../test/sr630.evidence.json")
	assert.NoError(t, err)

	var ev api.Evidence
	err = json.Unmarshal(buf, &ev)
	assert.NoError(t, err)
	sha1bank := map[string]api.Buffer{
		"0":  []byte("\x65\xCB\xDF\xF2\x8D\xF5\x8F\x4A\x75\x53\x31\x66\x53\x9B\x8E\x0A\x46\x08\x83\x27"),
		"1":  []byte("\x31\x93\x4F\x06\x68\xB8\xBF\x6B\x16\x14\x92\x5E\x05\xC5\xC1\xAB\x54\xE2\xC4\xE0"),
		"2":  []byte("\x08\x69\xE4\x99\xD0\x91\xCA\x49\x6F\x76\x48\xA6\x13\xD8\x4E\xAD\xE2\x99\x2F\x41"),
		"3":  []byte("\xB2\xA8\x3B\x0E\xBF\x2F\x83\x74\x29\x9A\x5B\x2B\xDF\xC3\x1E\xA9\x55\xAD\x72\x36"),
		"4":  []byte("\x49\xA8\x2E\x2A\xE1\xFA\x57\x69\x96\xC5\x6C\xD5\x89\xBE\x99\xCE\x22\x8E\xE3\xD8"),
		"5":  []byte("\x61\x2F\xE8\x7E\x8C\x43\xD2\x2E\xC5\xCB\x5B\xC4\x1B\xDA\x01\xA4\x36\xA2\xDF\xF9"),
		"6":  []byte("\xB2\xA8\x3B\x0E\xBF\x2F\x83\x74\x29\x9A\x5B\x2B\xDF\xC3\x1E\xA9\x55\xAD\x72\x36"),
		"7":  []byte("\x72\x76\xFA\x63\x19\x72\x6F\x55\x03\xB0\x5A\x4D\x1B\x3D\xC4\x91\xE1\x39\x33\xCC"),
		"8":  []byte("\xE1\x1E\x92\x32\x68\x71\x02\xD7\xBE\xF3\xD8\x61\xF1\x32\xC4\x50\x02\xF2\xFB\x75"),
		"9":  []byte("\x03\x18\xA2\x2E\xB6\xD3\x0C\xEA\x76\xE7\xCD\xA0\x0B\x02\x5F\xFC\x90\x92\xC0\x1F"),
		"10": []byte("\x00\x1D\x09\x12\x65\x5D\xE7\xA2\x7A\x6C\x46\x5B\xD4\x94\x45\xEC\x4D\xFB\xEF\xA5"),
		"11": []byte("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"),
		"12": []byte("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"),
		"13": []byte("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"),
		"14": []byte("\x77\xDB\x66\xD6\x0A\xA0\xC2\xCD\x1C\xEA\x6C\x34\xFE\xD4\xF2\xAA\x01\x4B\xF2\x85"),
		"15": []byte("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"),
		"16": []byte("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"),
		"17": []byte("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"),
		"18": []byte("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"),
		"19": []byte("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"),
		"20": []byte("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"),
		"21": []byte("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"),
		"22": []byte("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"),
		"23": []byte("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"),
	}
	sha256bank := map[string]api.Buffer{
		"0":  []byte("\x42\x6A\x5C\xF0\xFC\xE3\x6C\x28\xE5\xAF\x16\x2A\x16\x58\x79\xC5\x5E\x10\xC0\xE7\x8A\x30\x1B\x33\x00\x17\x0B\x59\x9F\x22\xE9\x26"),
		"1":  []byte("\xAE\x0E\xB2\xF9\xBC\x33\xE4\xA8\x73\xBB\x23\x53\x32\x83\x4F\xC9\xBC\x02\x66\xBE\x85\x94\x3C\x6A\x18\x66\xF7\x34\x9C\x9E\x83\xFA"),
		"2":  []byte("\x4D\x75\xEE\x8E\x8E\xB1\x14\x84\x5E\x44\x6F\x1F\x7E\x34\xB8\x05\x79\x50\x6C\x51\x99\xEB\x9C\x8B\x03\xE6\xBD\x83\x54\x9D\x3C\x3D"),
		"3":  []byte("\x3D\x45\x8C\xFE\x55\xCC\x03\xEA\x1F\x44\x3F\x15\x62\xBE\xEC\x8D\xF5\x1C\x75\xE1\x4A\x9F\xCF\x9A\x72\x34\xA1\x3F\x19\x8E\x79\x69"),
		"4":  []byte("\x5E\x6F\x52\x0D\x84\x0A\x9E\x12\xC8\xF1\x9F\xAC\xA1\x8E\x33\x61\x74\x94\x03\x0B\xAE\x65\x7E\x0D\x0F\xB4\x2B\x18\xDC\x61\x7B\x14"),
		"5":  []byte("\x32\xB5\x05\xB9\x38\x82\xB1\x91\xC9\x6C\xC0\xEF\xC0\x79\xC9\xAA\x02\xCC\xF5\x7A\x0A\xCB\xAD\xB4\xE4\xDB\x40\xBA\x63\xBE\x7C\x9D"),
		"6":  []byte("\x3D\x45\x8C\xFE\x55\xCC\x03\xEA\x1F\x44\x3F\x15\x62\xBE\xEC\x8D\xF5\x1C\x75\xE1\x4A\x9F\xCF\x9A\x72\x34\xA1\x3F\x19\x8E\x79\x69"),
		"7":  []byte("\xB3\xA9\xD0\x08\x7E\xD4\xC4\xC4\xF7\x38\x31\x0F\x92\x9F\x75\xF8\x7F\x55\xC1\xAE\xF0\x9C\x4D\xC8\x61\x69\xFC\xC4\x22\x38\xB5\x1E"),
		"8":  []byte("\x42\x2B\x20\x0E\xB0\x66\x1B\xF9\x77\xE4\x38\xAC\x20\x8A\x7C\xB8\x02\x02\x8D\xD5\x4E\x56\x8E\x21\xFB\x06\x82\xA0\xF2\xB5\xED\x78"),
		"9":  []byte("\xED\x09\x20\x26\xF9\x95\xAD\xA4\xB4\xC4\x8F\x23\x18\xBB\xE4\xF7\xED\xB0\x97\xDF\xBF\x25\xF5\xCA\x78\xA9\xAA\x4B\xA4\xCF\x07\x4B"),
		"10": []byte("\x52\x5D\x0F\x4D\x51\x12\xC8\xDC\x5C\x75\xBC\x44\xE5\x26\x21\xBE\x1C\x84\x6A\x96\x34\x22\xE0\xA3\x44\xC5\xF5\x5F\x81\x3D\x0B\xAC"),
		"11": []byte("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"),
		"12": []byte("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"),
		"13": []byte("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"),
		"14": []byte("\xE3\x99\x1B\x7D\xDD\x47\xBE\x7E\x92\x72\x6A\x83\x2D\x68\x74\xC5\x34\x9B\x52\xB7\x89\xFA\x0D\xB8\xB5\x58\xC6\x9F\xEA\x29\x57\x4E"),
		"15": []byte("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"),
		"16": []byte("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"),
		"17": []byte("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"),
		"18": []byte("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"),
		"19": []byte("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"),
		"20": []byte("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"),
		"21": []byte("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"),
		"22": []byte("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"),
		"23": []byte("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"),
	}

	ev.AllPCRs = map[string]map[string]api.Buffer{
		"11": sha256bank,
		"4":  sha1bank,
	}
	ev.PCRs = sha256bank

	imalog, err := ioutil.ReadFile("../../test/h12ssl.binary_measurements")
	assert.NoError(t, err)
	encoder, err := zstd.NewWriter(nil)
	assert.NoError(t, err)
	ev.Firmware.IMALog = new(api.ErrorBuffer)
	ev.Firmware.IMALog.Data = encoder.EncodeAll(imalog, make([]byte, 0, len(imalog)))

	evlog, err := ioutil.ReadFile("../../test/h12ssl.bios_measurements")
	assert.NoError(t, err)
	ev.Firmware.TPM2EventLog.Data = evlog
	wev, err := evidence.WrapInsecure(&ev)
	assert.NoError(t, err)
	subj, err := NewSubject(context.Background(), wev, baseline.New(), policy.New())
	assert.NoError(t, err)

	res, err := Run(ctx, subj)
	assert.NoError(t, err)
	for _, ann := range res.Issues {
		assert.NotEqual(t, issuesv1.ImaBootAggregateId, ann.Id())
	}

	ev.AllPCRs["4"]["10"][0] ^= 0xff
	wev, err = evidence.WrapInsecure(&ev)
	assert.NoError(t, err)

	subj, err = NewSubject(context.Background(), wev, baseline.New(), policy.New())
	assert.NoError(t, err)

	res, err = Run(ctx, subj)
	assert.NoError(t, err)
	hit := false
	for _, ann := range res.Issues {
		hit = hit || issuesv1.ImaInvalidLogId == ann.Id()
	}
	assert.True(t, hit)
}

func loadIMALog(t *testing.T, s string) *api.ErrorBuffer {
	imalog, err := ioutil.ReadFile(s)
	assert.NoError(t, err)
	encoder, err := zstd.NewWriter(nil)
	assert.NoError(t, err)

	return &api.ErrorBuffer{Data: encoder.EncodeAll(imalog, make([]byte, 0, len(imalog)))}
}

func TestIMAFileChanged(t *testing.T) {
	buf, err := ioutil.ReadFile("../../test/sr630.evidence.json")
	assert.NoError(t, err)

	var ev1, ev2 api.Evidence

	// no file
	err = json.Unmarshal(buf, &ev1)
	assert.NoError(t, err)
	ev1.Firmware.IMALog = loadIMALog(t, "../../test/h12ssl.created.measurements")
	err = json.Unmarshal(buf, &ev2)
	assert.NoError(t, err)
	ev2.Firmware.IMALog = loadIMALog(t, "../../test/h12ssl.changed.measurements")

	pol := policy.New()
	pol.ProtectedFiles = []policy.ProtectedFile{
		{
			Path: "/root/.ssh/authorized_keys",
		},
	}
	wev1, err := evidence.WrapInsecure(&ev1)
	assert.NoError(t, err)
	wev2, err := evidence.WrapInsecure(&ev2)
	assert.NoError(t, err)
	before, err := NewSubject(context.Background(), wev1, baseline.New(), pol)
	assert.NoError(t, err)
	after, err := NewSubject(context.Background(), wev2, baseline.New(), pol)
	assert.NoError(t, err)

	testCheckImpl(t, before, after, imaFiles{}, issuesv1.ImaRuntimeMeasurementsId, false, func(subject *Subject) {})
}

func TestIMALogUnsupportedBank(t *testing.T) {
	ctx := context.Background()
	buf, err := ioutil.ReadFile("../../test/sr630.evidence.json")
	assert.NoError(t, err)

	var ev api.Evidence
	err = json.Unmarshal(buf, &ev)
	assert.NoError(t, err)
	sha384bank := map[string]api.Buffer{
		"0": []byte("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"),
	}
	ev.AllPCRs = map[string]map[string]api.Buffer{
		"12": sha384bank,
	}
	ev.PCRs = sha384bank

	imalog, err := ioutil.ReadFile("../../test/h12ssl.binary_measurements")
	assert.NoError(t, err)
	encoder, err := zstd.NewWriter(nil)
	assert.NoError(t, err)
	ev.Firmware.IMALog = new(api.ErrorBuffer)
	ev.Firmware.IMALog.Data = encoder.EncodeAll(imalog, make([]byte, 0, len(imalog)))

	evlog, err := ioutil.ReadFile("../../test/h12ssl.bios_measurements")
	assert.NoError(t, err)
	ev.Firmware.TPM2EventLog.Data = evlog
	wev, err := evidence.WrapInsecure(&ev)
	assert.NoError(t, err)
	subj, err := NewSubject(context.Background(), wev, baseline.New(), policy.New())
	assert.NoError(t, err)

	// doesn't panic
	Run(ctx, subj)
}

func TestInvalidIMALog(t *testing.T) {
	testPure(t,
		"../../test/sr630.evidence.json",
		"../../test/sr630.evidence.json",
		imaLog{},
		issuesv1.ImaInvalidLogId,
		func(subj *Subject) {
			ev, ok := subj.IMALog[0].(eventlog.ImaNgEvent)
			if ok {
				ev.Digest[0] ^= 0xff
				subj.IMALog[0] = ev
			}
		})
}
