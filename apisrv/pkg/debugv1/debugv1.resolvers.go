package debugv1

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.27

import (
	"context"
	"sort"

	"github.com/99designs/gqlgen/graphql"
	graphql1 "github.com/immune-gmbh/guard/apisrv/v2/internal/graphql"
	"github.com/immune-gmbh/guard/apisrv/v2/pkg/binarly"
	"github.com/immune-gmbh/guard/apisrv/v2/pkg/database"
	"github.com/immune-gmbh/guard/apisrv/v2/pkg/evidence"
	"github.com/immune-gmbh/guard/apisrv/v2/pkg/organization"
	"github.com/immune-gmbh/guard/apisrv/v2/pkg/queue"
)

// Job is the resolver for the job field.
func (r *queryResolver) Job(ctx context.Context, id *string, typeArg *string, reference *string) (*graphql1.Job, error) {
	var (
		row *queue.Row
		err error
	)

	idSet := id != nil
	refTySet := (reference != nil) && (typeArg != nil)

	if idSet && !refTySet {
		row, err = queue.ById(ctx, r.pool, *id)
	} else if !idSet && refTySet {
		row, err = queue.ByReference(ctx, r.pool, *typeArg, *reference)
	} else {
		return nil, errIdXorRef
	}

	if err != nil {
		return nil, err
	}
	return convertJob(row)
}

// Jobs is the resolver for the jobs field.
func (r *queryResolver) Jobs(ctx context.Context, limit *int, filter *graphql1.JobFilter, order *graphql1.JobSort) ([]*graphql1.Job, error) {
	l := 10
	if limit != nil {
		l = *limit
	}
	var filters []interface{}
	if filter != nil {
		idSet := len(filter.ID) > 0
		idLt := filter.IDLt != nil
		refSet := len(filter.Reference) > 0
		refLt := filter.ReferenceLt != nil
		ty := len(filter.Type) > 0
		st := filter.Stauts != nil

		if idSet {
			filters = append(filters, queue.FilterId{Set: filter.ID})
		}
		if idLt {
			filters = append(filters, queue.FilterId{LessThan: *filter.IDLt})
		}
		if st {
			switch *filter.Stauts {
			case graphql1.JobStatusRunning:
				filters = append(filters, queue.FilterStatus{Status: queue.Running})
			case graphql1.JobStatusQueued:
				filters = append(filters, queue.FilterStatus{Status: queue.Queued})
			case graphql1.JobStatusFailed:
				filters = append(filters, queue.FilterStatus{Status: queue.Failed})
			case graphql1.JobStatusDone:
				filters = append(filters, queue.FilterStatus{Status: queue.Done})
			}
		}
		if ty {
			filters = append(filters, queue.FilterType{Types: filter.Type})
		}
		if refSet {
			filters = append(filters, queue.FilterReference{Set: filter.Reference})
		}
		if refLt {
			filters = append(filters, queue.FilterReference{LessThan: *filter.ReferenceLt})
		}
	}
	o := queue.Id
	if order != nil {
		switch *order {
		default:
			fallthrough
		case graphql1.JobSortID:
			o = queue.Id
		case graphql1.JobSortReference:
			o = queue.Reference
		case graphql1.JobSortScheduledAt:
			o = queue.ScheduledAt
		case graphql1.JobSortNextRunAt:
			o = queue.NextRunAt
		case graphql1.JobSortLockedAt:
			o = queue.LockedAt
		case graphql1.JobSortFinishedAt:
			o = queue.FinishedAt
		}
	}

	conn := database.ExplainQuerier{Database: r.pool}
	rows, err := queue.List(ctx, conn, l, o, graphql.CollectAllFields(ctx), filters...)
	if err != nil {
		return nil, err
	}

	jobs := make([]*graphql1.Job, len(rows))
	for i := range rows {
		j, err := convertJob(rows[i])
		if err != nil {
			return nil, err
		}
		jobs[i] = j
	}

	return jobs, nil
}

// Evidence is the resolver for the evidence field.
func (r *queryResolver) Evidence(ctx context.Context, deviceID *string, orgID *string, ref *string) (*graphql1.Evidence, error) {
	fields := graphql.CollectAllFields(ctx)
	sort.Strings(fields)
	includeBinarly := sort.SearchStrings(fields, "raw_binarly") < len(fields)

	var ev *evidence.Row
	if deviceID != nil && orgID != nil && ref == nil {
		org, err := organization.Get(ctx, r.pool, *orgID)
		if err != nil {
			return nil, err
		}
		ev, err = evidence.MostRecent(ctx, r.pool, *deviceID, org.Id)
		if err != nil {
			return nil, err
		}
	} else if deviceID == nil && orgID == nil && ref != nil {
		evs, err := evidence.ByReference(ctx, r.pool, *ref)
		if err != nil {
			return nil, err
		}
		if len(evs) == 0 {
			return nil, database.ErrNotFound
		}
		ev = &evs[0]
	}
	if ev == nil {
		return nil, errDeviceIdOrRef
	}

	var rep *binarly.Report
	if includeBinarly && ev.BinarlyReference != nil {
		var err error
		rep, err = binarly.Fetch(ctx, r.pool, *ev.BinarlyReference)
		if err != nil {
			return nil, err
		}
	}

	return convertEvidence(ev, rep)
}

// Query returns graphql1.QueryResolver implementation.
func (r *Resolver) Query() graphql1.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
